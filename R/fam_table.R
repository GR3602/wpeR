#' Prepares pedigree data for plotting and spatial representation
#'
#' @description `fam_table` combines pedigree and sample data for visual ([`ped_satplot`])
#'  and spatial ([`ped_spatial`]) representation of the pedigree.
#'
#' @details
#' * `sampledata` has to include columns that contain information on:
#'   - unique identifier of each sample; character or numeric (default column name = `Sample`),
#'   - date of sample collection in `Date` format (default = `Date`),
#'   - assignment of sample to particular individual; character or numeric (default = `AnimalRef`),
#'   - sex of the animal coded as `F`, `M` or `NA`; character (default = `GeneticSex`),
#'   - value that shows which sample is reference sample for each individual; boolean
#'       coded as `1` or `0` (default = `IsAnimalReference`),
#'   - longitude and latitude coordinates of sample collection location; numeric (default = `X` and `Y`),
#'   - type of particular sample eg. scat, tissue, saliva; character (default = `SType`),
#'   - date of first and last sample of individual in `Date` format
#'       (default = `FirstSeen` and `LastSeen`, see [`anim_timespan`] function),
#'   - value identifying if if the individual is dead; logical
#'       (default = `IsDead`, see [`anim_timespan`] function).
#'
#'
#'
#' @param fams data frame. (Subset of) family (`fams`) data generated by [`org_fams`] function.
#'   Just families that we want to plot have to be selected.
#' @param all.fams data frame. Family (`fams`) data generated by [`org_fams`] function.
#' @param ped data frame. Organized pedigree (`ped`) generated by [`org_fams`] function.
#' @param sampledata data frame. Metadata for all genetic samples that belong
#' to the individuals included in pedigree reconstruction analysis.
#' For description of `sampledata` structure and sample information needed for `fam_table()` see Details.
#' @param datacolumns vector of column names included `sampledata` that are needed to produce
#' this functions output (see Details).
#' @param deadSample single value or vector of different lethal sample types.
#' Defaults to c("Tissue", "Decomposing Tissue", "Bone").
#'
#' @return
#' Extended `sampledata` data frame that includes all columns defined in `datacolumns`
#' parameter and adds information needed for visual and spatial representation of
#' pedigree:
#'   * `plottingID`: numeric. Identifier number for temporal pedigree plot
#'    [`ped_satplot`]. In case of polygamous animals same individual
#'    can be included in more than one family,
#'   * `FamID`: numeric. Identifier number of family that individual belongs to,
#'   * `polyCluster`: numeric. Identifier number for the poygami cluster of individual,
#'   * `alpha`: logical. Is individual reproductive in current family,
#'    (current family defined with `FamID` for a particular entry),
#'   * `later_alpha`: logical. Is individual reproductive in any other (later) families,
#'   * `isPolygamous`: logical. Has individual more than one mate,
#'   * `dead`: logical. Is individual dead,
#'   * `first_sample`: logical. Is this particular sample the first sample of individual,
#'   * `last_sample`: logical. Is this particular sample the last sample of individual,
#'   * `isReference`: logical. Is this particular sample reference sample of individual.
#'
#' @export
#'
#' @examples
#' animal_ts <- anim_timespan(pack21_samples$AnimalRef,
#'                                   pack21_samples$Date,
#'                                   pack21_samples$SType,
#'                                   dead = c("Tissue", "Decomposing Tissue", "Blood"))
#'
#' sampledata <- merge(pack21_samples, animal_ts, by.x = "AnimalRef", by.y = "ID", all.x = TRUE )
#'
#' path <- paste0(system.file("extdata", package = "wpeR"), "/fake_colony")
#'
#' ped_colony <- get_colony(path, sampledata, remove_obsolete_parents = TRUE, out = "FamAgg")
#'
#' org_tables <- org_fams(ped_colony, sampledata, output = "both")
#'
#'
#' fam_table(org_tables$fams,
#'           org_tables$fams,
#'           org_tables$ped,
#'           sampledata,
#'           deadSample = c("Tissue", "Decomposing Tissue", "Blood"))
#'
fam_table<- function(fams, all.fams, ped, sampledata,
                     datacolumns = c("Sample", "AnimalRef", "GeneticSex", "Date", "SType", "X", "Y", "FirstSeen", "LastSeen", "IsDead"),
                     deadSample = c("Tissue", "Decomposing Tissue", "Bone")) {

  #simplified PackPlot function, output just table
  #Wrapper for PedigreeCMRSatplot
  #prepares data for plotting
  #packs = packs data (from 'org_fams' function), selected only packs we want to plot.
  #all.packs = all packs data. To find later alphas.
  #ped = organized pedigree from the same function
  #sampledata = as the name suggests


  outdata = NULL
  plottingID = 1 #ID for plotting, since the same animal can be drawn in more families in polygamy

  ##loop fills the outdata table with data from sampledata[datacolumn,], adds famID, polycluster and creates plottingID, alpha (if animal is reporductive), later_alpha (if animal repoductive in later season), is Polyamous (if it has offsping with more than one other animal)
  ##plottingID marks all the samples of the same animal
  ##loop starts with reproducitve males after that reporducitve females and than other animals. Eventhough the loop is segmeted it does the same things for all animals
  for (i in 1:nrow(fams)) {
    #Get Alphas, write in outdata
    if(!grepl("//*", fams$father[i])) {

      fatherSamples = sampledata[sampledata$AnimalRef == fams$father[i], datacolumns]

      fatherSamples$plottingID = rep(plottingID, nrow(fatherSamples))
      plottingID = plottingID +1

      fatherSamples$FamID = rep(fams$FamID[i], nrow(fatherSamples))
      fatherSamples$polyCluster = rep(fams$polyCluster[i], nrow(fatherSamples))
      fatherSamples$alpha = rep(TRUE, nrow(fatherSamples))
      fatherSamples$later_alpha = rep(FALSE, nrow(fatherSamples)) #does the animal become alpha later

      if(!is.na(fams$DadPclust[i])) fatherSamples$isPolygamous = rep(TRUE, nrow(fatherSamples))
      else fatherSamples$isPolygamous = rep(FALSE, nrow(fatherSamples))# if Dad polygamous cluster is not NA, then TRUE

      outdata = rbind(outdata, fatherSamples)
    }

    if(!grepl("#", fams$mother[i])) {

      motherSamples = sampledata[sampledata$AnimalRef == fams$mother[i], datacolumns]

      motherSamples$plottingID = rep(plottingID, nrow(motherSamples))
      plottingID = plottingID +1

      motherSamples$FamID = rep(fams$FamID[i], nrow(motherSamples))
      motherSamples$polyCluster = rep(fams$polyCluster[i], nrow(motherSamples))
      motherSamples$alpha = rep(TRUE, nrow(motherSamples))
      motherSamples$later_alpha = rep(FALSE, nrow(motherSamples)) #does the animal become alpha later

      if(!is.na(fams$MomPclust[i])) motherSamples$isPolygamous = rep(TRUE, nrow(motherSamples))
      else motherSamples$isPolygamous = rep(FALSE, nrow(motherSamples))# if Mom polygamous cluster is not NA, then TRUE

      outdata = rbind(outdata, motherSamples)
    }

    #Get other animals, write in outdata
    sub_ped = ped[ped$FamID == fams$FamID[i],]

    for(j in 1:nrow(sub_ped)) {

      offspringSamples = sampledata[sampledata$AnimalRef == sub_ped$id[j], datacolumns]

      offspringSamples$plottingID = rep(plottingID, nrow(offspringSamples))
      plottingID = plottingID +1

      offspringSamples$FamID = rep(fams$FamID[i], nrow(offspringSamples))
      offspringSamples$polyCluster = rep(fams$polyCluster[i], nrow(offspringSamples))
      offspringSamples$alpha = rep(FALSE, nrow(offspringSamples))

      if (sum(grepl(sub_ped$id[j], all.fams$father) | grepl(sub_ped$id[j], all.fams$mother)) > 0)
        offspringSamples$later_alpha = rep(TRUE, nrow(offspringSamples)) #the animal becomes alpha later
      else offspringSamples$later_alpha = rep(FALSE, nrow(offspringSamples))

      offspringSamples$isPolygamous = rep(FALSE, nrow(offspringSamples))

      outdata = rbind(outdata, offspringSamples)
    }
  } #fams loop

  #mark mortality samples
  ## based on deadSample vectors and sample type adds column isDead (TRUE/FALSE)
  outdata$dead = outdata$SType %in% deadSample

  #mark first sample, mark last sample
  ##new columns first_sample, last_sampel, IsReference, at first all FALSE
  outdata$first_sample = rep(FALSE, nrow(outdata))
  outdata$last_sample = rep(FALSE, nrow(outdata))
  outdata$IsReference = rep(FALSE, nrow(outdata))

  ##fills in columns created above
  for (i in 1:(nrow(outdata))){

    #need this junk to catch NAs
    minDt =  min(outdata$Date[outdata$plottingID == outdata$plottingID[i]], na.rm=T)
    maxDt =  max(outdata$Date[outdata$plottingID == outdata$plottingID[i]], na.rm=T)

    if(!is.na(outdata$Date[i]) & minDt != Inf & maxDt != -Inf){
      if (outdata$Date[i] == minDt) outdata$first_sample[i] = TRUE
      if (outdata$Date[i] == maxDt) outdata$last_sample[i] = TRUE
    }
    if (outdata$Sample[i] == outdata$AnimalRef[i]) outdata$IsReference[i] = TRUE
  }

  outdata$first_sample[outdata$first_sample == Inf] = NA #samples that have only NA's for data
  outdata$last_sample[outdata$last_sample == -Inf] = NA

  unique_out = unique(outdata$plottingID)

  #get rid of duplicates that occur when there are several "first" or "last" samples (collected on the same date)

  for (i in 1:length(unique_out)){

    animal_samps_frst = outdata$plottingID == unique_out[i] & outdata$first_sample == T
    animal_samps_lst = outdata$plottingID == unique_out[i] & outdata$last_sample == T

    #if more than one first or last, retain only the flag on the first one
    if (sum(animal_samps_frst) > 1)
      outdata$first_sample[outdata$plottingID == unique_out[i] & outdata$first_sample == T][2:sum(animal_samps_frst)] = FALSE

    if (sum(animal_samps_lst) > 1)
      outdata$last_sample[outdata$plottingID == unique_out[i] & outdata$last_sample == T][2:sum(animal_samps_lst)] = FALSE
  }


  return(outdata)


}
